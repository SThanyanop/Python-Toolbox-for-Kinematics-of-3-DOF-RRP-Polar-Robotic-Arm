# Optimize Toolbox - Workspace 3D Plot Documentation

## Overview

The `plot_workspace_3d()` method generates an interactive 3D visualization of the RRP (Revolute-Revolute-Prismatic) robotic arm's workspace. It displays the reachable area, grid structure, singularities, and a sample robot configuration with full interactive controls.

---

## Quick Start

```python
from Optimize_Toolbox import RRPToolbox

# Define robot parameters
link_params = [
    [(5, 0, 0), (0, 0, 5)],  # Link 1
    [(3, 0, 0)],             # Link 2
    [(0, 0, 0)]              # End Effector
]
joint_limits = [
    (0, 90),     # theta1 limits (degrees)
    (0, 180),    # theta2 limits (degrees)
    (3, 5)       # d3 limits (meters)
]

# Create toolbox instance
toolbox = RRPToolbox(link_params, joint_limits)

# Plot workspace with default parameters
toolbox.plot_workspace_3d()

# Plot with custom sampling density
toolbox.plot_workspace_3d(theta1_samples=15, theta2_samples=15, d3_samples=8)
```

---

## How It Works

### 1. **Workspace Generation**

#### Method: `get_workspace(theta1_samples, theta2_samples, d3_samples)`

The workspace is generated by sampling joint configurations and computing the end effector position for each:

**Sampling Strategy:**
- **θ1 (First Revolute Joint):** Sampled uniformly from min to max (default: 12 samples)
- **θ2 (Second Revolute Joint):** Sampled uniformly from min to max (default: 12 samples)  
- **d3 (Prismatic Joint):** Sampled ONLY at boundaries (min and max) - shows outer surfaces only

**Example with 12×12×2 sampling:**
- Total workspace points: 12 × 12 × 2 = 288 points
- These represent the end effector positions for all sampled joint combinations

#### Computation Process:

For each joint configuration `(θ1, θ2, d3)`:

1. **Start at base:** position = [0, 0, 0]

2. **Apply Link 1:** Rotate segments by θ1 around Z-axis
   ```
   rotated_x = cos(θ1) * x - sin(θ1) * y
   rotated_y = sin(θ1) * x + cos(θ1) * y
   rotated_z = z
   ```

3. **Apply Link 2:** Also rotated by θ1 around Z-axis (same rotation)

4. **Apply Prismatic Joint:** Extend in direction controlled by θ2
   ```
   direction = [sin(θ2)*cos(θ1), sin(θ2)*sin(θ1), cos(θ2)]
   position += d3 * direction
   ```

5. **Apply End Effector:** Move along the same direction

**Result:** List of (x, y, z) positions representing the workspace surface

---

### 2. **Singularity Detection**

#### Method: `find_singularities(theta1_samples, theta2_samples, d3_samples)`

Singularities are positions where the robot loses a degree of freedom (Jacobian determinant ≈ 0).

**Process:**
1. For each sampled joint configuration, compute the Jacobian matrix
2. Calculate the determinant
3. If |determinant| < threshold (1e-3), mark as singular
4. Compute forward kinematics to get 3D position
5. Store both configuration and position

**Why Important:**
- Singular configurations should be avoided for trajectory planning
- Visualized as **purple X markers** in the plot

---

### 3. **Grid Edge Connectivity**

Edges connect workspace vertices to form a grid structure. Three types of edges:

#### **Type 1: θ1 Direction (Horizontal Grid)**
- Connects points along θ1 variation (same θ2 and d3)
- Creates horizontal rings around the workspace
- **Applied at ALL θ2 and d3 values**

#### **Type 2: θ2 Direction (Perpendicular Grid)**
- Connects points along θ2 variation (same θ1 and d3)
- Creates vertical rings around the workspace
- **Applied at ALL θ1 and d3 values**

#### **Type 3: d3 Direction (Vertical Edges)**
- Connects inner surface (d3_min) to outer surface (d3_max)
- Represents prismatic joint extension
- **Applied ONLY at θ1 and θ2 boundaries** to avoid clutter

**Implementation:**
```python
# Point mapping from (theta1_idx, theta2_idx, d3_idx) to point_index
point_map = {}
for i in range(theta1_samples):
    for j in range(theta2_samples):
        for d3_idx in range(2):  # 0=min, 1=max
            point_map[(i, j, d3_idx)] = point_index

# Connect θ1 direction edges
for j in range(theta2_samples):
    for d3_idx in range(2):
        for i in range(theta1_samples - 1):
            # Connect point (i,j,d3) to (i+1,j,d3)
            draw_edge(point_map[(i,j,d3_idx)], point_map[(i+1,j,d3_idx)])
```

---

### 4. **Workspace Face Generation**

Faces create surfaces between connected edges, showing the workspace boundary.

#### **Three Types of Faces:**

**Type 1: θ1-θ2 Plane Faces**
- Rectangular faces perpendicular to d3 direction
- Filled for each d3 layer (d3_min and d3_max)
- Formula: Connect 4 corners at (i,j), (i+1,j), (i+1,j+1), (i,j+1)

**Type 2: Boundary Faces at θ2 Limits**
- Connect d3_min to d3_max surface
- Applied at θ2_min and θ2_max boundaries
- Shows the "walls" of the workspace

**Type 3: Boundary Faces at θ1 Limits**
- Connect d3_min to d3_max surface
- Applied at θ1_min and θ1_max boundaries
- Completes the workspace envelope

#### **Duplicate Elimination:**
Faces are tracked using a `face_set` to prevent duplicates:
```python
face_key = tuple(sorted([idx1, idx2, idx3, idx4]))
if face_key not in face_set:
    face_set.add(face_key)
    add_face_to_plot(face)
```

---

### 5. **Robot Visualization**

The current robot configuration is displayed with:

- **Base (green square):** Reference point at origin [0, 0, 0]
- **Link 1 (steel blue):** First revolute arm segment
- **Link 2 (coral):** Second revolute arm segment
- **Prismatic Joint (green):** Extendable d3 element
- **End Effector (red):** Tool attachment point
- **Joint markers (circles):** Connection points between links

**Default Configuration:**
```
θ1 = 0°          (minimum theta1)
θ2 = 0°          (minimum theta2)
d3 = 5 (maximum) (maximum extension)
```

---

## Interactive Controls

### **Sliders**

| Slider | Range | Function |
|--------|-------|----------|
| **Elevation** | -90° to 90° | Vertical camera angle (up/down tilt) |
| **Azimuth** | -180° to 180° | Horizontal camera angle (left/right rotation) |

### **Toggle Buttons**

| Button | Function |
|--------|----------|
| **Hide/Show Vertices** | Toggle visibility of workspace grid points (blue dots) |
| **Hide/Show Faces** | Toggle visibility of workspace surface (cyan transparent areas) |

### **Mouse Controls**

- **Left-click + Drag:** Rotate view freely (matplotlib default)
- **Right-click + Drag:** Zoom in/out
- **Middle-click + Drag:** Pan view

---

## Visual Elements Explained

### **Color Scheme:**

| Element | Color | Meaning |
|---------|-------|---------|
| **Workspace Vertices** | Blue (viridis colormap) | Grid points, colored by height (Z-axis) |
| **Workspace Edges** | Blue line | Grid connectivity |
| **Workspace Faces** | Cyan (transparent) | Reachable workspace surface |
| **Singularities** | Purple X | Configurations where robot loses DOF |
| **Link 1** | Steel Blue | First arm segment |
| **Link 2** | Coral | Second arm segment |
| **Prismatic (d3)** | Green circle/line | Extendable element |
| **End Effector** | Red | Tool tip position |
| **Base** | Green square | Reference origin |

### **Colorbar:**
- Shows Z-axis height scale
- Lighter colors = lower (smaller Z)
- Darker colors = higher (larger Z)

---

## Algorithm Breakdown

### **Step 1: Generate Workspace Points**
```
for each θ1 in [min, max]:
    for each θ2 in [min, max]:
        for each d3 in [min, max]:  // Only 2 values: min and max
            point = forward_kinematics(θ1, θ2, d3)
            workspace_points.append(point)
```

### **Step 2: Find Singularities**
```
for each (θ1, θ2, d3) sampled at coarser resolution:
    J = compute_jacobian(θ1, θ2, d3)
    det_J = determinant(J)
    if |det_J| < threshold:
        position = forward_kinematics(θ1, θ2, d3)
        singularity_positions.append(position)
```

### **Step 3: Connect Edges**
```
Create point_map: (i, j, d3_idx) -> point_index

// Type 1: θ1 direction
for each j, d3_idx:
    for i = 0 to theta1_samples-2:
        draw_line(point[i,j,d3], point[i+1,j,d3])

// Type 2: θ2 direction
for each i, d3_idx:
    for j = 0 to theta2_samples-2:
        draw_line(point[i,j,d3], point[i,j+1,d3])

// Type 3: d3 direction (boundaries only)
for each i, j at boundaries:
    draw_line(point[i,j,d3_min], point[i,j,d3_max])
```

### **Step 4: Create Faces**
```
faces = []

// Type 1: θ1-θ2 rectangular faces
for each i, d3_idx, j:
    quad = [point[i,j,d3], point[i+1,j,d3], 
            point[i+1,j+1,d3], point[i,j+1,d3]]
    if not duplicate:
        faces.append(quad)

// Type 2 & 3: Boundary faces (similar logic)

plot_faces_with_transparency(faces)
```

### **Step 5: Plot Robot Configuration**
```
θ1, θ2, d3 = current_configuration
positions = trace_robot_segments(θ1, θ2, d3)
plot_links_with_colors(positions)
plot_base_marker(origin)
```

---

## Performance Considerations

### **Sampling Density Impact**

| Sampling | Points | Edges | Time | Quality |
|----------|--------|-------|------|---------|
| 10×10×2 | 200 | ~400 | Fast | Coarse |
| 15×15×2 | 450 | ~850 | Medium | Good |
| 25×25×2 | 1,250 | ~2,500 | Slower | Smooth |

**Recommendation:** Start with 12×12×2 for initial visualization, increase to 25×25×2 for detailed analysis.

### **Optimization Tips:**

1. **Reduce sampling** for faster rendering:
   ```python
   toolbox.plot_workspace_3d(theta1_samples=10, theta2_samples=10)
   ```

2. **Hide faces initially** (toggle button) to see structure faster

3. **Use interactive sliders** to explore specific configurations before full workspace

---

## Mathematical Formulas

### **Forward Kinematics for RRP Robot**

Position of end effector after d3 extension:

$$x = d_3 \sin(\theta_2) \cos(\theta_1)$$
$$y = d_3 \sin(\theta_2) \sin(\theta_1)$$
$$z = z_1 + z_2 + d_3 \cos(\theta_2)$$

Where $z_1, z_2$ are the Z-components of Link 1 and Link 2 in the base frame.

### **Jacobian Determinant (Singularity Indicator)**

For RRP robot, singularities occur when:
$$\det(J) \approx 0$$

Where $J$ is the 3×3Jacobian relating joint velocities to end effector velocities.

### **Workspace Volume Approximation**

Approximate workspace volume using convex hull of workspace points (if scipy available):
```python
from scipy.spatial import ConvexHull
hull = ConvexHull(workspace_points)
volume = hull.volume
```

---

## Common Use Cases

### **1. Reachability Analysis**
Visualize which positions the robot can reach with current joint limits.

### **2. Singularity Avoidance**
Identify purple X markers and plan trajectories avoiding those regions.

### **3. Workspace Optimization**
Adjust joint limits and observe how workspace changes.

### **4. Configuration Space Exploration**
Use sliders to test different joint angles and see robot configurations.

### **5. Presentation & Documentation**
Export snapshots from different angles for reports and documentation.

---

## Troubleshooting

### **Issue: Workspace looks hollow/missing sections**

**Solution:** This is intentional! We only sample d3 at boundaries to show the outer surface. To see intermediate d3 values:
```python
# Modify get_workspace() to sample all d3 values
d3_range = [d3_min + (d3_max - d3_min) * i / (d3_samples - 1) 
            for i in range(d3_samples)]
```

### **Issue: Animation/rotation is slow**

**Solution:** Reduce sampling density:
```python
toolbox.plot_workspace_3d(theta1_samples=8, theta2_samples=8)
```

### **Issue: Cannot see workspace grid**

**Solution:** 
1. Click "Show Vertices" button to ensure vertices are visible
2. Rotate view to see edges (use sliders or mouse)
3. Toggle "Show Faces" if needed

### **Issue: Singularities not showing**

**Solution:** Singularities may be sparse depending on robot configuration. Try:
```python
# Increase singularity sampling in find_singularities()
singularities, configs = toolbox.find_singularities(
    theta1_samples=30, theta2_samples=30, d3_samples=20
)
```

---

## API Reference

### **plot_workspace_3d(theta1_samples=25, theta2_samples=25, d3_samples=15)**

**Parameters:**
- `theta1_samples` (int): Number of samples for θ1 (default: 25)
- `theta2_samples` (int): Number of samples for θ2 (default: 25)
- `d3_samples` (int): Unused (always samples d3 at min/max only)

**Returns:** None (displays plot)

**Raises:**
- `ImportError`: If matplotlib, scipy, or numpy not installed
- `ValueError`: If not enough points to compute workspace

---

## Advanced Features

### **Accessing Workspace Data Programmatically**

```python
# Get raw workspace points
workspace_points = toolbox.get_workspace(12, 12, 2)
print(f"Total points: {len(workspace_points)}")

# Get singularity information
singularities, configs = toolbox.find_singularities(20, 20, 10)
for config, position in configs:
    print(f"Singular at: {config} -> Position: {position}")

# Save workspace for later analysis
import numpy as np
np.save('workspace.npy', np.array(workspace_points))
```

### **Combining Workspace with Other Analysis**

```python
# Visualize workspace AND test a trajectory
toolbox.plot_workspace_3d(15, 15, 5)

# Then test trajectory on the same robot
test_waypoints = [(0, 0, 3), (45, 90, 4), (90, 45, 5)]
toolbox.animate_trajectory(test_waypoints, total_time=8)
```

---

## References

- **Forward Kinematics:** Computed using DH (Denavit-Hartenberg) matrices
- **Inverse Kinematics:** Analytical solution with workspace boundary checking
- **Singularities:** Detected using Jacobian determinant threshold (1e-3)
- **Visualization:** matplotlib 3D with Poly3DCollection for faces

---

## See Also

- `interactive_plot()` - Real-time joint control with sliders
- `animate_trajectory()` - Trajectory animation with time-based interpolation
- `Forward_Kinematics()` - Single configuration analysis
- `Inverse_Kinematics()` - Target position solving
- `get_RRP_Jacobian_Matrix()` - Singularity computation

