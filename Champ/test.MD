# Mathematics of Workspace 3D Plot - Optimize_Toolbox.py

## Executive Summary

The workspace 3D plot visualizes all end-effector positions reachable by an RRP robot through systematic sampling of joint configurations and computing their corresponding Cartesian coordinates using forward kinematics.

---

## 1. Robot Configuration & Parameters

### 1.1 Robot Structure (RRP Configuration)

The RRP robot consists of:
- **Joint 1 (θ₁):** Revolute joint (rotation about Z-axis) - **Base rotation**
- **Joint 2 (θ₂):** Revolute joint (rotation about Y-axis) - **Arm elevation**
- **Joint 3 (d₃):** Prismatic joint (translation) - **Linear extension**

### 1.2 Link Parameters

Given as segments in 3D space. Each link is represented as a list of 3D vectors:

**Link Parameters Structure:**
- Link 1: $[(x_1, y_1, z_1), (x_2, y_2, z_2), \ldots]$
- Link 2: $[(x_3, y_3, z_3), \ldots]$
- End Effector: $[(x_4, y_4, z_4), \ldots]$

**Example:**
```
Link 1: [(5, 0, 0), (0, 0, 5)]    # 5m horizontal + 5m vertical
Link 2: [(3, 0, 0)]              # 3m horizontal
End Effector: [(0, 0, 0)]        # Point mass
```

### 1.3 Joint Limits

$$\begin{align}
\theta_1 &\in [\theta_{1,min}, \theta_{1,max}]\\
\theta_2 &\in [\theta_{2,min}, \theta_{2,max}]\\
d_3 &\in [d_{3,min}, d_{3,max}]
\end{align}$$

---

## 2. Workspace Generation Algorithm

### 2.1 Sampling Strategy

The workspace is generated by discretizing the joint space into a uniform grid:

**Number of samples:**
- θ₁: $N_1$ samples (default: 10)
- θ₂: $N_2$ samples (default: 10)
- d₃: Only 2 values ($d_{3,min}$ and $d_{3,max}$) - always samples boundaries, ignores parameter

**Total workspace points:** $P = N_1 \times N_2 \times 2$ (d₃ always sampled at min and max)

**Example:** $10 \times 10 \times 2 = 200$ points

### 2.2 Joint Space Grid

For each dimension, create uniform samples:

$$\theta_1^{(i)} = \theta_{1,min} + \frac{i}{N_1-1}(\theta_{1,max} - \theta_{1,min}), \quad i = 0, 1, ..., N_1-1$$

$$\theta_2^{(j)} = \theta_{2,min} + \frac{j}{N_2-1}(\theta_{2,max} - \theta_{2,min}), \quad j = 0, 1, ..., N_2-1$$

For d₃, only boundary values are sampled:
$$d_3^{(k)} \in \{d_{3,min}, d_{3,max}\}, \quad k \in \{0, 1\}$$

### 2.3 Forward Kinematics - Core Computation

For each joint configuration $\mathbf{q} = (\theta_1, \theta_2, d_3)$, compute the end-effector position $\mathbf{p}$ using forward kinematics.

---

## 3. Forward Kinematics for Workspace Plotting

In the workspace generation, a simplified approach using direct rotation matrices is used:

**For Link 1 and Link 2 segments:**

Rotation by θ₁ around Z-axis:

$$R_z(\theta_1) = \begin{bmatrix} \cos\theta_1 & -\sin\theta_1 & 0 \\ \sin\theta_1 & \cos\theta_1 & 0 \\ 0 & 0 & 1 \end{bmatrix}$$

**Applied to each segment:**

$$\begin{bmatrix} x' \\ y' \\ z' \end{bmatrix} = R_z(\theta_1) \begin{bmatrix} x \\ y \\ z \end{bmatrix}$$

**For Prismatic Joint (d₃):**

Direction vector controlled by θ₂:

$$\mathbf{d} = \begin{bmatrix} \sin(\theta_2)\cos(\theta_1) \\ \sin(\theta_2)\sin(\theta_1) \\ \cos(\theta_2) \end{bmatrix}$$

**Extension:**
$$\mathbf{p}_{d_3} = d_3 \cdot \mathbf{d}$$

---

## 4. Workspace Point Computation

### 4.1 Algorithm Pseudocode

```
function ComputeWorkspace(N₁, N₂):
    workspace_points ← empty list
    
    for i = 0 to N₁-1:
        θ₁ᵢ ← θ₁,min + i/(N₁-1) × (θ₁,max - θ₁,min)
        
        for j = 0 to N₂-1:
            θ₂ⱼ ← θ₂,min + j/(N₂-1) × (θ₂,max - θ₂,min)
            
            for k = 0 to 1:
                if k = 0: d₃ₖ ← d₃,min
                else: d₃ₖ ← d₃,max
                
                // Compute forward kinematics
                pᵢⱼₖ ← ForwardKinematics(θ₁ᵢ, θ₂ⱼ, d₃ₖ)
                
                workspace_points.append(pᵢⱼₖ)
    
    return workspace_points
```

### 4.2 Mathematical Formulation

The workspace is the set of all end-effector positions reachable by varying joint parameters:

**Configuration ranges:**
- $\theta_1 \in [\theta_{1,min}, \theta_{1,max}]$
- $\theta_2 \in [\theta_{2,min}, \theta_{2,max}]$
- $d_3 \in \{d_{3,min}, d_{3,max}\}$ (only boundary values)

Where $\mathbf{p}(\theta_1, \theta_2, d_3)$ is the end-effector position computed via forward kinematics.

### 4.3 Position Accumulation

Starting from the base at origin $\mathbf{p}_0 = [0, 0, 0]$:

**Step 1: Apply Link 1 segments**

$\mathbf{p}_1 = \mathbf{p}_0 + \sum_{s_1 \in \text{Link1}} R_z(\theta_1) \cdot \mathbf{s}_1$

**Step 2: Apply Link 2 segments**

$\mathbf{p}_2 = \mathbf{p}_1 + \sum_{s_2 \in \text{Link2}} R_z(\theta_1) \cdot \mathbf{s}_2$

**Step 3: Apply Prismatic Joint**

$\mathbf{p}_3 = \mathbf{p}_2 + d_3 \cdot \mathbf{d}(\theta_2, \theta_1)$

**Step 4: Apply End Effector segments**

$\mathbf{p}_{EE} = \mathbf{p}_3 + \sum_{s_e \in \text{EE}} \|\mathbf{s}_e\| \cdot \mathbf{d}(\theta_2, \theta_1)$

---

## 5. Edge Connectivity - Grid Structure

### 5.1 Point Indexing

Each point is indexed by a triplet $(i, j, k)$ where:
- $i$: Index in θ₁ dimension ($i \in [0, N_1-1]$)
- $j$: Index in θ₂ dimension ($j \in [0, N_2-1]$)
- $k$: d₃ value ($k \in \{d_{3,min}, d_{3,max}\}$)

**Linear index:**
$$\text{index}(i, j, k) = i \cdot N_2 \cdot 2 + j \cdot 2 + k^*$$

where $k^* = 0$ if $k = d_{3,min}$, else $k^* = 1$

### 5.2 Edge Types

#### **Type 1: θ₁ Direction Edges**

Connects adjacent points varying only in θ₁:
$$\text{Edge}: \mathbf{p}(i, j, k) \to \mathbf{p}(i+1, j, k)$$

**Condition:** $i = 0, 1, ..., N_1-2$ for all $j$ and $k \in \{d_{3,min}, d_{3,max}\}$

**Number of Type 1 edges:** $(N_1-1) \times N_2 \times 2$

#### **Type 2: θ₂ Direction Edges**

Connects adjacent points varying only in θ₂:
$$\text{Edge}: \mathbf{p}(i, j, k) \to \mathbf{p}(i, j+1, k)$$

**Condition:** $j = 0, 1, ..., N_2-2$ for all $i$ and $k \in \{d_{3,min}, d_{3,max}\}$

**Number of Type 2 edges:** $N_1 \times (N_2-1) \times 2$

#### **Type 3: d₃ Direction Edges**

Connects the two d₃ surfaces ($d_{3,min}$ to $d_{3,max}$):
$$\text{Edge}: \mathbf{p}(i, j, d_{3,min}) \to \mathbf{p}(i, j, d_{3,max})$$

**Condition:** Only at grid boundaries: $(i \in \{0, N_1-1\}) \text{ OR } (j \in \{0, N_2-1\})$

**Number of Type 3 edges:** $2(N_1-1) + 2(N_2-1)$

---

## 6. Face Generation - Surface Representation

### 6.1 Face Types

#### **Type A: Rectangular Faces in θ₁-θ₂ Plane**

For each d₃ layer ($d_{3,min}$ and $d_{3,max}$):
$$\text{Face} = \{\mathbf{p}(i,j,d_3), \mathbf{p}(i+1,j,d_3), \mathbf{p}(i+1,j+1,d_3), \mathbf{p}(i,j+1,d_3)\}$$

Where:
- $i = 0, 1, ..., N_1-2$
- $j = 0, 1, ..., N_2-2$
- $d_3 \in \{d_{3,min}, d_{3,max}\}$ (both layers)

**Number of Type A faces:** $2 \times (N_1-1) \times (N_2-1)$

#### **Type B: Boundary Faces at θ₂ Limits**

Connect $d_{3,min}$ to $d_{3,max}$ at $j = 0$ (θ₂_min) and $j = N_2-1$ (θ₂_max):
$$\text{Face} = \{\mathbf{p}(i,j,d_{3,min}), \mathbf{p}(i+1,j,d_{3,min}), \mathbf{p}(i+1,j,d_{3,max}), \mathbf{p}(i,j,d_{3,max})\}$$

**Number of Type B faces:** $2 \times (N_1-1)$

#### **Type C: Boundary Faces at θ₁ Limits**

Connect $d_{3,min}$ to $d_{3,max}$ at $i = 0$ (θ₁_min) and $i = N_1-1$ (θ₁_max):
$$\text{Face} = \{\mathbf{p}(i,j,d_{3,min}), \mathbf{p}(i,j+1,d_{3,min}), \mathbf{p}(i,j+1,d_{3,max}), \mathbf{p}(i,j,d_{3,max})\}$$

**Number of Type C faces:** $2 \times (N_2-1)$

---

## 6. Duplicate Elimination

Each face is represented as a sorted 4-tuple of point indices.

**Face key creation:** Sort the indices $(i_1, i_2, i_3, i_4)$ to create a unique identifier.

**Duplicate tracking:** A set $S$ stores all processed face keys. Before adding a face to the visualization, check if its key is already in $S$.

**Result:** Only faces with unique keys are rendered, ensuring no duplicate surfaces in the plot.

---

## 7. Singularity Detection

### 7.1 Jacobian Matrix

The Jacobian relates joint velocities to end-effector velocities:
$$\dot{\mathbf{p}} = J(\mathbf{q}) \cdot \dot{\mathbf{q}}$$

For the RRP robot, the 3×3 reduced Jacobian is:

$$J = \begin{bmatrix}
\frac{\partial x}{\partial \theta_1} & \frac{\partial x}{\partial \theta_2} & \frac{\partial x}{\partial d_3} \\
\frac{\partial y}{\partial \theta_1} & \frac{\partial y}{\partial \theta_2} & \frac{\partial y}{\partial d_3} \\
\frac{\partial z}{\partial \theta_1} & \frac{\partial z}{\partial \theta_2} & \frac{\partial z}{\partial d_3}
\end{bmatrix}$$

### 7.2 Determinant Computation

For 3×3 matrix:
$$\det(J) = a_{11}(a_{22}a_{33} - a_{23}a_{32}) - a_{12}(a_{21}a_{33} - a_{23}a_{31}) + a_{13}(a_{21}a_{32} - a_{22}a_{31})$$

### 7.3 Singularity Criterion

A configuration is **singular** if:
$$|\det(J)| < \epsilon$$

Where $\epsilon = 10^{-3}$ (threshold)

### 7.4 Singularity Sampling

Singularities are detected at a coarser resolution to reduce computation:
$$N_1^{sing} = \max(8, \lfloor N_1/2 \rfloor)$$
$$N_2^{sing} = \max(8, \lfloor N_2/2 \rfloor)$$
$$N_3^{sing} = \max(5, \lfloor N_3/2 \rfloor)$$

---

## 8. Visualization Mapping

### 8.1 3D Coordinate Transformation

Workspace points (computed in Cartesian coordinates) are directly plotted:
$$\text{Plot}(\mathbf{p}) = (x, y, z) \text{ where } \mathbf{p} = [x, y, z]^T$$

### 8.2 Color Mapping for Vertices

All workspace vertices use **the same marker shape** (circles) and are colored using the viridis colormap based **only on Z-coordinate (height)**:

$$\text{color} = \text{colormap}(\text{normalize}(z_i))$$

Where normalization maps Z values to $[0, 1]$:
$$z_{norm} = \frac{z_i - z_{min}}{z_{max} - z_{min}}$$

**Coloring behavior:**
- Low Z values → Dark color (near purple)
- High Z values → Bright color (near yellow)
- Vertices with **same height** appear the same color, **regardless of d₃ value**

**Why d₃_min and d₃_max surfaces look similar:**
Since both surfaces may have overlapping Z-heights, they receive similar colors from the viridis colormap. The vertices are visually indistinguishable by color alone.