# Mathematics of Workspace 3D Plot - Optimize_Toolbox.py

## Executive Summary

The workspace 3D plot visualizes all end-effector positions reachable by an RRP robot through systematic sampling of joint configurations and computing their corresponding Cartesian coordinates using forward kinematics.

---

## 1. Robot Configuration & Parameters

### 1.1 Robot Structure (RRP Configuration)

The RRP robot consists of:
- **Joint 1 (θ₁):** Revolute joint (rotation about Z-axis) - **Base rotation**
- **Joint 2 (θ₂):** Revolute joint (rotation about Y-axis) - **Arm elevation**
- **Joint 3 (d₃):** Prismatic joint (translation) - **Linear extension**

### 1.2 Link Parameters

Given as segments in 3D space. Each link is represented as a list of 3D vectors:

**Link Parameters Structure:**
- Link 1: $[(x_1, y_1, z_1), (x_2, y_2, z_2), \ldots]$
- Link 2: $[(x_3, y_3, z_3), \ldots]$
- End Effector: $[(x_4, y_4, z_4), \ldots]$

**Example:**
```
Link 1: [(5, 0, 0), (0, 0, 5)]    # 5m horizontal + 5m vertical
Link 2: [(3, 0, 0)]              # 3m horizontal
End Effector: [(0, 0, 0)]        # Point mass
```

### 1.3 Joint Limits

$$\begin{align}
\theta_1 &\in [\theta_{1,min}, \theta_{1,max}] = [0°, 90°] \\
\theta_2 &\in [\theta_{2,min}, \theta_{2,max}] = [0°, 180°] \\
d_3 &\in [d_{3,min}, d_{3,max}] = [3, 5] \text{ meters}
\end{align}$$

---

## 2. Workspace Generation Algorithm

### 2.1 Sampling Strategy

The workspace is generated by discretizing the joint space into a uniform grid:

**Number of samples:**
- θ₁: $N_1$ samples (default: 12)
- θ₂: $N_2$ samples (default: 12)
- d₃: $N_3 = 2$ (always min and max only)

**Total workspace points:** $P = N_1 \times N_2 \times N_3$

**Example:** $12 \times 12 \times 2 = 288$ points

### 2.2 Joint Space Grid

For each dimension, create uniform samples:

$$\theta_1^{(i)} = \theta_{1,min} + \frac{i}{N_1-1}(\theta_{1,max} - \theta_{1,min}), \quad i = 0, 1, ..., N_1-1$$

$$\theta_2^{(j)} = \theta_{2,min} + \frac{j}{N_2-1}(\theta_{2,max} - \theta_{2,min}), \quad j = 0, 1, ..., N_2-1$$

$$d_3^{(k)} = \begin{cases}
d_{3,min} & k = 0 \\
d_{3,max} & k = 1
\end{cases}$$

### 2.3 Forward Kinematics - Core Computation

For each joint configuration $\mathbf{q} = (\theta_1, \theta_2, d_3)$, compute the end-effector position $\mathbf{p}$ using forward kinematics.

---

## 3. Forward Kinematics Derivation

### 3.1 DH Matrix Approach

The Optimize_Toolbox uses DH (Denavit-Hartenberg) matrices. Each transformation is defined as:

$$T_i = \begin{bmatrix}
\cos(\theta_i) & -\sin(\theta_i)\cos(\alpha_i) & \sin(\theta_i)\sin(\alpha_i) & a_i\cos(\theta_i) \\
\sin(\theta_i) & \cos(\theta_i)\cos(\alpha_i) & -\cos(\theta_i)\sin(\alpha_i) & a_i\sin(\theta_i) \\
0 & \sin(\alpha_i) & \cos(\alpha_i) & d_i \\
0 & 0 & 0 & 1
\end{bmatrix}$$

Where:
- $a_i$: Link length along current frame X-axis
- $\alpha_i$: Twist angle around current frame X-axis
- $d_i$: Joint offset along Z-axis
- $\theta_i$: Joint angle

### 3.2 DH Parameters for RRP Robot

| Frame | $a_i$ | $\alpha_i$ | $d_i$ | $\theta_i$ |
|-------|-------|-----------|-------|-----------|
| 0→1 | 0 | 0° | 0 | **θ₁** |
| 1→2 | $x_1$ | 0° | $z_1$ | 0 |
| 2→3 | 0 | 90° | $y_1$ | **θ₂** |
| 3→4 | $x_2$ | 0° | $y_2$ | 90° |
| 4→5 | $z_2$ | 90° | 0 | 0 |
| 5→6 | $z_3$ | 0° | $x_3 + d_3$ | 90° |
| 6→EE | $y_3$ | 90° | 0 | 90° |

### 3.3 Complete Transformation Matrix

$$T_{total} = T_0 \cdot T_1 \cdot T_2 \cdot T_3 \cdot T_4 \cdot T_5 \cdot T_6 \cdot T_{EE}$$

The end-effector position is extracted as:

$$\mathbf{p} = \begin{bmatrix} T[0][3] \\ T[1][3] \\ T[2][3] \end{bmatrix}$$

### 3.4 Simplified Forward Kinematics (Direct Rotation)

In the workspace generation, a simplified approach using direct rotation matrices is used:

**For Link 1 and Link 2 segments:**

Rotation by θ₁ around Z-axis:

$$R_z(\theta_1) = \begin{bmatrix} \cos\theta_1 & -\sin\theta_1 & 0 \\ \sin\theta_1 & \cos\theta_1 & 0 \\ 0 & 0 & 1 \end{bmatrix}$$

**Applied to each segment:**

$$\begin{bmatrix} x' \\ y' \\ z' \end{bmatrix} = R_z(\theta_1) \begin{bmatrix} x \\ y \\ z \end{bmatrix}$$

**For Prismatic Joint (d₃):**

Direction vector controlled by θ₂:

$$\mathbf{d} = \begin{bmatrix} \sin(\theta_2)\cos(\theta_1) \\ \sin(\theta_2)\sin(\theta_1) \\ \cos(\theta_2) \end{bmatrix}$$

**Extension:**
$$\mathbf{p}_{d_3} = d_3 \cdot \mathbf{d}$$

---

## 4. Workspace Point Computation

### 4.1 Algorithm Pseudocode

```
function ComputeWorkspace(N₁, N₂):
    workspace_points ← empty list
    
    for i = 0 to N₁-1:
        θ₁ᵢ ← θ₁,min + i/(N₁-1) × (θ₁,max - θ₁,min)
        
        for j = 0 to N₂-1:
            θ₂ⱼ ← θ₂,min + j/(N₂-1) × (θ₂,max - θ₂,min)
            
            for k = 0 to 1:
                if k = 0: d₃ₖ ← d₃,min
                else: d₃ₖ ← d₃,max
                
                // Compute forward kinematics
                pᵢⱼₖ ← ForwardKinematics(θ₁ᵢ, θ₂ⱼ, d₃ₖ)
                
                workspace_points.append(pᵢⱼₖ)
    
    return workspace_points
```

### 4.2 Mathematical Formulation

The workspace is the set of all end-effector positions reachable by varying joint parameters:

**Configuration ranges:**
- $\theta_1 \in [\theta_{1,min}, \theta_{1,max}]$
- $\theta_2 \in [\theta_{2,min}, \theta_{2,max}]$
- $d_3 \in \{d_{3,min}, d_{3,max}\}$ (only boundary values)

Where $\mathbf{p}(\theta_1, \theta_2, d_3)$ is the end-effector position computed via forward kinematics.

### 4.3 Position Accumulation

Starting from the base at origin $\mathbf{p}_0 = [0, 0, 0]$:

**Step 1: Apply Link 1 segments**
$\mathbf{p}_1 = \mathbf{p}_0 + \sum_{s_1 \in \text{Link1}} R_z(\theta_1) \cdot \mathbf{s}_1$

**Step 2: Apply Link 2 segments**
$\mathbf{p}_2 = \mathbf{p}_1 + \sum_{s_2 \in \text{Link2}} R_z(\theta_1) \cdot \mathbf{s}_2$

**Step 3: Apply Prismatic Joint**
$\mathbf{p}_3 = \mathbf{p}_2 + d_3 \cdot \mathbf{d}(\theta_2, \theta_1)$

**Step 4: Apply End Effector segments**
$\mathbf{p}_{EE} = \mathbf{p}_3 + \sum_{s_e \in \text{EE}} \|\mathbf{s}_e\| \cdot \mathbf{d}(\theta_2, \theta_1)$

---

## 5. Edge Connectivity - Grid Structure

### 5.1 Point Indexing

Each point is indexed by a triplet $(i, j, k)$ where:
- $i$: Index in θ₁ dimension ($i \in [0, N_1-1]$)
- $j$: Index in θ₂ dimension ($j \in [0, N_2-1]$)
- $k$: Index in d₃ dimension ($k \in \{0, 1\}$ for min/max)

**Linear index:**
$$\text{index}(i, j, k) = i \cdot N_2 \cdot 2 + j \cdot 2 + k$$

### 5.2 Edge Types

#### **Type 1: θ₁ Direction Edges**

Connects adjacent points varying only in θ₁:
$$\text{Edge}: \mathbf{p}(i, j, k) \to \mathbf{p}(i+1, j, k)$$

**Condition:** $i = 0, 1, ..., N_1-2$ for all $j, k$

**Number of Type 1 edges:** $(N_1-1) \times N_2 \times 2$

#### **Type 2: θ₂ Direction Edges**

Connects adjacent points varying only in θ₂:
$$\text{Edge}: \mathbf{p}(i, j, k) \to \mathbf{p}(i, j+1, k)$$

**Condition:** $j = 0, 1, ..., N_2-2$ for all $i, k$

**Number of Type 2 edges:** $N_1 \times (N_2-1) \times 2$

#### **Type 3: d₃ Direction Edges**

Connects the two d₃ surfaces (min to max):
$$\text{Edge}: \mathbf{p}(i, j, 0) \to \mathbf{p}(i, j, 1)$$

**Condition:** Only at boundaries: $(i \in \{0, N_1-1\}) \text{ OR } (j \in \{0, N_2-1\})$

**Number of Type 3 edges:** $2(N_1-1) + 2(N_2-1)$

### 5.3 Total Edge Count

$$E_{total} = (N_1-1)N_2 \cdot 2 + N_1(N_2-1) \cdot 2 + 2(N_1-1) + 2(N_2-1)$$

For $N_1 = N_2 = 12$:
$$E_{total} = 11 \cdot 12 \cdot 2 + 12 \cdot 11 \cdot 2 + 2(11) + 2(11) = 528 + 264 + 22 + 22 = 836$$

---

## 6. Face Generation - Surface Representation

### 6.1 Face Types

#### **Type A: Rectangular Faces in θ₁-θ₂ Plane**

For each d₃ layer (min and max):
$$\text{Face} = \{\mathbf{p}(i,j,k), \mathbf{p}(i+1,j,k), \mathbf{p}(i+1,j+1,k), \mathbf{p}(i,j+1,k)\}$$

Where:
- $i = 0, 1, ..., N_1-2$
- $j = 0, 1, ..., N_2-2$
- $k \in \{0, 1\}$ (both layers)

**Number of Type A faces:** $2 \times (N_1-1) \times (N_2-1)$

#### **Type B: Boundary Faces at θ₂ Limits**

Connect d₃_min to d₃_max at $j = 0$ (θ₂_min) and $j = N_2-1$ (θ₂_max):
$$\text{Face} = \{\mathbf{p}(i,j,0), \mathbf{p}(i+1,j,0), \mathbf{p}(i+1,j,1), \mathbf{p}(i,j,1)\}$$

**Number of Type B faces:** $2 \times (N_1-1)$

#### **Type C: Boundary Faces at θ₁ Limits**

Connect d₃_min to d₃_max at $i = 0$ (θ₁_min) and $i = N_1-1$ (θ₁_max):
$$\text{Face} = \{\mathbf{p}(i,j,0), \mathbf{p}(i,j+1,0), \mathbf{p}(i,j+1,1), \mathbf{p}(i,j,1)\}$$

**Number of Type C faces:** $2 \times (N_2-1)$

### 6.2 Total Face Count

$$F_{total} = 2(N_1-1)(N_2-1) + 2(N_1-1) + 2(N_2-1)$$

For $N_1 = N_2 = 12$:
$$F_{total} = 2 \times 11 \times 11 + 2 \times 11 + 2 \times 11 = 242 + 22 + 22 = 286$$

### 6.3 Duplicate Elimination

Each face is represented as a sorted 4-tuple of point indices.

**Face key creation:** Sort the indices $(i_1, i_2, i_3, i_4)$ to create a unique identifier.

**Duplicate tracking:** A set $S$ stores all processed face keys. Before adding a face to the visualization, check if its key is already in $S$.

**Result:** Only faces with unique keys are rendered, ensuring no duplicate surfaces in the plot.

---

## 7. Singularity Detection

### 7.1 Jacobian Matrix

The Jacobian relates joint velocities to end-effector velocities:
$$\dot{\mathbf{p}} = J(\mathbf{q}) \cdot \dot{\mathbf{q}}$$

For the RRP robot, the 3×3 reduced Jacobian is:

$$J = \begin{bmatrix}
\frac{\partial x}{\partial \theta_1} & \frac{\partial x}{\partial \theta_2} & \frac{\partial x}{\partial d_3} \\
\frac{\partial y}{\partial \theta_1} & \frac{\partial y}{\partial \theta_2} & \frac{\partial y}{\partial d_3} \\
\frac{\partial z}{\partial \theta_1} & \frac{\partial z}{\partial \theta_2} & \frac{\partial z}{\partial d_3}
\end{bmatrix}$$

### 7.2 Determinant Computation

For 3×3 matrix:
$$\det(J) = a_{11}(a_{22}a_{33} - a_{23}a_{32}) - a_{12}(a_{21}a_{33} - a_{23}a_{31}) + a_{13}(a_{21}a_{32} - a_{22}a_{31})$$

### 7.3 Singularity Criterion

A configuration is **singular** if:
$$|\det(J)| < \epsilon$$

Where $\epsilon = 10^{-3}$ (threshold)

### 7.4 Singularity Sampling

Singularities are detected at a coarser resolution to reduce computation:
$$N_1^{sing} = \max(8, \lfloor N_1/2 \rfloor)$$
$$N_2^{sing} = \max(8, \lfloor N_2/2 \rfloor)$$
$$N_3^{sing} = \max(5, \lfloor N_3/2 \rfloor)$$

---

## 8. Visualization Mapping

### 8.1 3D Coordinate Transformation

Workspace points (computed in Cartesian coordinates) are directly plotted:
$$\text{Plot}(\mathbf{p}) = (x, y, z) \text{ where } \mathbf{p} = [x, y, z]^T$$

### 8.2 Color Mapping for Vertices

Vertices are colored using the viridis colormap based on Z-coordinate:
$$\text{color} = \text{colormap}(\text{normalize}(z_i))$$

Where normalization maps Z values to $[0, 1]$:
$$z_{norm} = \frac{z_i - z_{min}}{z_{max} - z_{min}}$$

### 8.3 Face Transparency

Faces are rendered with:
- **Alpha (transparency):** $\alpha = 0.25$ (75% transparent)
- **Face color:** Cyan
- **Edge color:** None (no black edges)

---

## 9. Computational Complexity

### 9.1 Time Complexity

| Operation | Complexity | Notes |
|-----------|-----------|-------|
| Workspace generation | $O(N_1 \cdot N_2)$ | Forward kinematics for each point |
| Edge creation | $O(N_1 \cdot N_2)$ | Linear traversal of all edges |
| Face creation | $O(N_1 \cdot N_2)$ | Linear traversal of all faces |
| Singularity detection | $O(N_1^{sing} \cdot N_2^{sing} \cdot N_3^{sing})$ | Jacobian computation |
| Total rendering | $O(N_1 \cdot N_2 \cdot \log N)$ | Polygon depth sorting for transparency |

**Typical time for 25×25 sampling:** 2-5 seconds

### 9.2 Space Complexity

| Data | Size |
|------|------|
| Workspace points | $O(N_1 \cdot N_2 \cdot 2) = O(N_1 \cdot N_2)$ |
| Edges | $O(N_1 \cdot N_2)$ |
| Faces | $O(N_1 \cdot N_2)$ |
| Singularities | $O(N_1^{sing} \cdot N_2^{sing} \cdot N_3^{sing})$ |
| Total | $O(N_1 \cdot N_2)$ |

---

## 10. Mathematical Properties of RRP Workspace

### 10.1 Workspace Boundary

The workspace boundary is approximated by the convex hull of all sampled points:

$$\partial \mathcal{W} = \text{ConvexHull}(\{\mathbf{p}_i \mid i = 1, ..., N_1 \cdot N_2 \cdot 2\})$$

### 10.2 Workspace Dimensions

**Maximum reach:**
$$r_{max} = L_1 + L_2 + d_{3,max}$$

Where $L_1$, $L_2$ are link lengths.

**Minimum reach:**
$$r_{min} = d_{3,min}$$

**Height range:**
$$\Delta z = [z_{min}, z_{max}]$$

### 10.3 Workspace Volume (Approximate)

Using convex hull:
$$V_{\mathcal{W}} = \text{Volume(ConvexHull)}$$

---

## 11. Example Calculation

### 11.1 Given Parameters

```
Link 1: [(5, 0, 0), (0, 0, 5)]
Link 2: [(3, 0, 0)]
End Effector: [(0, 0, 0)]

Joint limits:
θ₁ ∈ [0°, 90°]
θ₂ ∈ [0°, 180°]
d₃ ∈ [3, 5]

Sampling: N₁ = 3, N₂ = 2 (simplified for illustration)
```

### 11.2 Sample Grid

**θ₁ values:** [0°, 45°, 90°] (3 samples)
**θ₂ values:** [0°, 180°] (2 samples)
**d₃ values:** [3, 5] (2 samples)

### 11.3 Point Computation Example

**Configuration 1: θ₁=0°, θ₂=0°, d₃=3**

```
1. Base: p₀ = [0, 0, 0]

2. Link 1 segment (5,0,0):
   R_z(0°) · [5,0,0]ᵀ = [5,0,0]ᵀ
   p₁ = [5, 0, 0]

3. Link 1 segment (0,0,5):
   R_z(0°) · [0,0,5]ᵀ = [0,0,5]ᵀ
   p₂ = [5, 0, 5]

4. Link 2 segment (3,0,0):
   R_z(0°) · [3,0,0]ᵀ = [3,0,0]ᵀ
   p₃ = [8, 0, 5]

5. Prismatic (d₃=3):
   d = [sin(0°)cos(0°), sin(0°)sin(0°), cos(0°)]ᵀ = [0,0,1]ᵀ
   p₄ = [8, 0, 5] + 3·[0,0,1]ᵀ = [8, 0, 8]

6. End effector: p_EE = [8, 0, 8]
```

**Configuration 2: θ₁=45°, θ₂=90°, d₃=5**

```
1. Base: p₀ = [0, 0, 0]

2. Link 1 segment (5,0,0):
   R_z(45°) · [5,0,0]ᵀ = [3.536, 3.536, 0]ᵀ
   p₁ = [3.536, 3.536, 0]

3. Link 1 segment (0,0,5):
   R_z(45°) · [0,0,5]ᵀ = [0,0,5]ᵀ
   p₂ = [3.536, 3.536, 5]

4. Link 2 segment (3,0,0):
   R_z(45°) · [3,0,0]ᵀ = [2.121, 2.121, 0]ᵀ
   p₃ = [5.657, 5.657, 5]

5. Prismatic (d₃=5):
   d = [sin(90°)cos(45°), sin(90°)sin(45°), cos(90°)]ᵀ = [0.707, 0.707, 0]ᵀ
   p₄ = [5.657, 5.657, 5] + 5·[0.707, 0.707, 0]ᵀ = [9.202, 9.202, 5]

6. End effector: p_EE = [9.202, 9.202, 5]
```

---

## 12. Key Mathematical Insights

### 12.1 Why Only d₃ Boundaries?

Sampling d₃ only at min/max shows the outer **surface** of the workspace:
- Inner surface: $d_{3,min}$ extension
- Outer surface: $d_{3,max}$ extension
- Connecting edges show the prismatic range

This reduces points from $N_1 \times N_2 \times N_3$ to $N_1 \times N_2 \times 2$.

### 12.2 Rotation Matrix Properties

For Z-axis rotation:
$$R_z(\theta) = \begin{bmatrix} \cos\theta & -\sin\theta & 0 \\ \sin\theta & \cos\theta & 0 \\ 0 & 0 & 1 \end{bmatrix}$$

Properties:
- Orthogonal: $R_z^T R_z = I$
- Determinant: $\det(R_z) = 1$
- Inverse: $R_z^{-1}(\theta) = R_z(-\theta)$

### 12.3 Singularity Geometric Meaning

When $\det(J) = 0$:
- The Jacobian loses full rank
- Robot loses ability to move in at least one Cartesian direction
- Typically occurs at configuration boundaries or extreme positions

---

## 13. Verification & Validation

### 13.1 Reachability Check

A point $\mathbf{p}$ is in workspace if:
$$\exists (\theta_1, \theta_2, d_3) \text{ s.t. } \mathbf{p} = \text{FK}(\theta_1, \theta_2, d_3)$$

This is verified by the forward kinematics computation.

### 13.2 Physical Constraints

All computed positions must satisfy:
- $\theta_1 \in [\theta_{1,min}, \theta_{1,max}]$
- $\theta_2 \in [\theta_{2,min}, \theta_{2,max}]$
- $d_3 \in [d_{3,min}, d_{3,max}]$

These are enforced during sampling.

---

## 14. References

1. **Robotics Fundamentals**
   - Forward Kinematics: Denavit-Hartenberg convention
   - Jacobian: Velocity kinematics from differential kinematics

2. **Computational Geometry**
   - Convex Hull: Point set boundary
   - Face Generation: Polygon mesh creation

3. **Numerical Methods**
   - Singularity Detection: Determinant computation
   - Sampling: Uniform grid discretization

---

## Appendix: Code Implementation Map

| Mathematical Concept | Code Location |
|----------------------|-----------------|
| Joint limits | `self.joint_limits` |
| Forward kinematics | `get_RRP_Tramsform_Matrix()` |
| Workspace generation | `get_workspace()` |
| Jacobian computation | `get_RRP_Jacobian_Matrix()` |
| Singularity detection | `find_singularities()` |
| Edge creation | Lines in `plot_workspace_3d()` |
| Face creation | Lines in `plot_workspace_3d()` |
| Visualization | matplotlib 3D plotting |

